! function(t, n) { "object" == typeof exports && "object" == typeof module ? module.exports = n(require("THREE")) : "function" == typeof define && define.amd ? define(["THREE"], n) : "object" == typeof exports ? exports.ThreeDxf = n(require("THREE")) : t.ThreeDxf = n(t.THREE) }("undefined" != typeof self ? self : this, function(__WEBPACK_EXTERNAL_MODULE__0__) { return function(t) { var n = {};

        function c(e) { if (n[e]) return n[e].exports; var l = n[e] = { i: e, l: !1, exports: {} }; return t[e].call(l.exports, l, l.exports, c), l.l = !0, l.exports } return c.m = t, c.c = n, c.d = function(t, n, e) { c.o(t, n) || Object.defineProperty(t, n, { enumerable: !0, get: e }) }, c.r = function(t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, c.t = function(t, n) { if (1 & n && (t = c(t)), 8 & n) return t; if (4 & n && "object" == typeof t && t && t.__esModule) return t; var e = Object.create(null); if (c.r(e), Object.defineProperty(e, "default", { enumerable: !0, value: t }), 2 & n && "string" != typeof t)
                for (var l in t) c.d(e, l, function(n) { return t[n] }.bind(null, l)); return e }, c.n = function(t) { var n = t && t.__esModule ? function() { return t.default } : function() { return t }; return c.d(n, "a", n), n }, c.o = function(t, n) { return Object.prototype.hasOwnProperty.call(t, n) }, c.p = "", c(c.s = 1) }([function(module, exports) { eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi9leHRlcm5hbCBcIlRIUkVFXCI/ZmMwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX187Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n") }, function(module, __webpack_exports__, __webpack_require__) { "use strict";
        eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "THREE"\nvar external_THREE_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/OrbitControls.js\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n/*global THREE, console */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\r\n// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\r\n// supported.\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\r\n//\r\n// This is a drop-in replacement for (most) TrackballControls used in examples.\r\n// That is, include this js file and wherever you see:\r\n//    \tcontrols = new THREE.TrackballControls( camera );\r\n//      controls.target.z = 150;\r\n// Simple substitute "OrbitControls" and the control should work as-is.\r\n\r\n\r\n\r\nfunction OrbitControls( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// "target" sets the location of focus, where the control orbits around\r\n\t// and where it pans with respect to.\r\n\tthis.target = new external_THREE_["Vector3"]();\r\n\r\n\t// center is old, deprecated; use "target" instead\r\n\tthis.center = this.target;\r\n\r\n\t// This option actually enables dollying in and out; left as "zoom" for\r\n\t// backwards compatibility\r\n\tthis.noZoom = false;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Limits to how far you can dolly in and out\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noRotate = false;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to true to disable this control\r\n\tthis.noPan = false;\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// Set to true to disable use of the keys\r\n\tthis.noKeys = false;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t////////////\r\n\t// internals\r\n\r\n\tvar scope = this;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar rotateStart = new external_THREE_["Vector2"]();\r\n\tvar rotateEnd = new external_THREE_["Vector2"]();\r\n\tvar rotateDelta = new external_THREE_["Vector2"]();\r\n\r\n\tvar panStart = new external_THREE_["Vector2"]();\r\n\tvar panEnd = new external_THREE_["Vector2"]();\r\n\tvar panDelta = new external_THREE_["Vector2"]();\r\n\tvar panOffset = new external_THREE_["Vector3"]();\r\n\r\n\tvar offset = new external_THREE_["Vector3"]();\r\n\r\n\tvar dollyStart = new external_THREE_["Vector2"]();\r\n\tvar dollyEnd = new external_THREE_["Vector2"]();\r\n\tvar dollyDelta = new external_THREE_["Vector2"]();\r\n\r\n\tvar phiDelta = 0;\r\n\tvar thetaDelta = 0;\r\n\tvar scale = 1;\r\n\tvar pan = new external_THREE_["Vector3"]();\r\n\r\n\tvar lastPosition = new external_THREE_["Vector3"]();\r\n\r\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\t// for reset\r\n\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: \'change\' };\r\n\tvar startEvent = { type: \'start\'};\r\n\tvar endEvent = { type: \'end\'};\r\n\r\n\tthis.rotateLeft = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tthetaDelta -= angle;\r\n\r\n\t};\r\n\r\n\tthis.rotateUp = function ( angle ) {\r\n\r\n\t\tif ( angle === undefined ) {\r\n\r\n\t\t\tangle = getAutoRotationAngle();\r\n\r\n\t\t}\r\n\r\n\t\tphiDelta -= angle;\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move left\r\n\tthis.panLeft = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get X column of matrix\r\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\tpanOffset.multiplyScalar( - distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\r\n\t// pass in distance in world space to move up\r\n\tthis.panUp = function ( distance ) {\r\n\r\n\t\tvar te = this.object.matrix.elements;\r\n\r\n\t\t// get Y column of matrix\r\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\tpanOffset.multiplyScalar( distance );\r\n\t\t\r\n\t\tpan.add( panOffset );\r\n\r\n\t};\r\n\t\r\n\t// pass in x,y of change desired in pixel space,\r\n\t// right and down are positive\r\n\tthis.pan = function ( deltaX, deltaY ) {\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( scope.object.fov !== undefined ) {\r\n\r\n\t\t\t// perspective\r\n\t\t\tvar position = scope.object.position;\r\n\t\t\tvar offset = position.clone().sub( scope.target );\r\n\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t// half of the fov is center to top of screen\r\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t// we actually don\'t use screenWidth, since perspective camera is fixed to screen height\r\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\r\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\r\n\r\n\t\t} else if ( scope.object.top !== undefined ) {\r\n            \r\n\t\t\t// orthographic\r\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\r\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// camera neither orthographic or perspective\r\n\t\t\tconsole.warn( \'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dollyIn = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale /= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.dollyOut = function ( dollyScale ) {\r\n\r\n\t\tif ( dollyScale === undefined ) {\r\n\r\n\t\t\tdollyScale = getZoomScale();\r\n\r\n\t\t}\r\n\r\n\t\tscale *= dollyScale;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n        \r\n        if(scope.object.top !== undefined) {\r\n            this.object.top = (scale*this.object.top);\r\n            this.object.bottom = (scale*this.object.bottom);\r\n            this.object.left = (scale*this.object.left);\r\n            this.object.right = (scale*this.object.right);\r\n            \r\n            this.object.updateProjectionMatrix();\r\n\r\n        }\r\n            \r\n\r\n\t\tvar position = this.object.position;\r\n\r\n\t\toffset.copy( position ).sub( this.target );\r\n//\r\n//\t\t// angle from z-axis around y-axis\r\n//\r\n//\t\tvar theta = Math.atan2( offset.x, offset.z );\r\n//\r\n//\t\t// angle from y-axis\r\n//\r\n//\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\r\n//\r\n//\t\tif ( this.autoRotate ) {\r\n//\r\n//\t\t\tthis.rotateLeft( getAutoRotationAngle() );\r\n//\r\n//\t\t}\r\n//\r\n//\t\ttheta += thetaDelta;\r\n//\t\tphi += phiDelta;\r\n//\r\n//\t\t// restrict phi to be between desired limits\r\n//\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\r\n//\r\n//\t\t// restrict phi to be betwee EPS and PI-EPS\r\n//\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\r\n//\r\n//\t\tvar radius = offset.length() * scale;\r\n//\r\n//\t\t// restrict radius to be between desired limits\r\n//\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\r\n//\t\t\r\n//\t\t// move target to panned location\r\n\t\tthis.target.add( pan );\r\n//\t\t\r\n//\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\r\n//\t\toffset.y = radius * Math.cos( phi );\r\n//\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\r\n//\r\n\t\tposition.copy( this.target ).add( offset );\r\n\r\n\t\tthis.object.lookAt( this.target );\r\n\r\n\r\n//\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 || scale !== 1 ) {\r\n\r\n\t\t\tthis.dispatchEvent( changeEvent );\r\n\r\n//\t\t\tlastPosition.copy( this.object.position );\r\n\r\n//\t\t}\r\n        \r\n//        thetaDelta = 0;\r\n//\t\tphiDelta = 0;\r\n\t\tscale = 1;\r\n\t\tpan.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t\tthis.target.copy( this.target0 );\r\n\t\tthis.object.position.copy( this.position0 );\r\n\r\n\t\tthis.update();\r\n\r\n\t};\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( event.button === 0 ) {\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 1 ) {\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t\t} else if ( event.button === 2 ) {\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t\t}\r\n\r\n\t\tscope.domElement.addEventListener( \'mousemove\', onMouseMove, false );\r\n\t\tscope.domElement.addEventListener( \'mouseup\', onMouseUp, false );\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\trotateEnd.set( event.clientX, event.clientY );\r\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t} else if ( state === STATE.DOLLY ) {\r\n\r\n\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\tpanEnd.set( event.clientX, event.clientY );\r\n\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\r\n\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.domElement.removeEventListener( \'mousemove\', onMouseMove, false );\r\n\t\tscope.domElement.removeEventListener( \'mouseup\', onMouseUp, false );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noZoom === true ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\r\n\r\n\t\t\tdelta = event.wheelDelta;\r\n\r\n\t\t} else if ( event.detail !== undefined ) { // Firefox\r\n\r\n\t\t\tdelta = - event.detail;\r\n\r\n\t\t}\r\n\r\n\t\tif ( delta > 0 ) {\r\n\r\n\t\t\tscope.dollyOut();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.dollyIn();\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\t\tscope.dispatchEvent( startEvent );\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\r\n\t\t\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\t\t\t\tdollyStart.set( 0, distance );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\r\n\t\t\t\tstate = STATE.TOUCH_PAN;\r\n\r\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.noRotate === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\r\n\r\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n\t\t\t\t// rotating across whole screen goes 360 degrees around\r\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n\t\t\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly\r\n\r\n\t\t\t\tif ( scope.noZoom === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\r\n\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tdollyEnd.set( 0, distance );\r\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\t\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\t\t\tscope.dollyOut();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscope.dollyIn();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3: // three-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.noPan === true ) return;\r\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\r\n\r\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\r\n\t\t\t\t\r\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\r\n\r\n\t\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchend( /* event */ ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tthis.domElement.addEventListener( \'contextmenu\', function ( event ) { event.preventDefault(); }, false );\r\n\tthis.domElement.addEventListener( \'mousedown\', onMouseDown, false );\r\n\tthis.domElement.addEventListener( \'mousewheel\', onMouseWheel, false );\r\n\tthis.domElement.addEventListener( \'DOMMouseScroll\', onMouseWheel, false ); // firefox\r\n\r\n\tthis.domElement.addEventListener( \'touchstart\', touchstart, false );\r\n\tthis.domElement.addEventListener( \'touchend\', touchend, false );\r\n\tthis.domElement.addEventListener( \'touchmove\', touchmove, false );\r\n\r\n\twindow.addEventListener( \'keydown\', onKeyDown, false );\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( external_THREE_["EventDispatcher"].prototype );\n// CONCATENATED MODULE: ./src/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return Viewer; });\n\r\n\r\n\r\n// Three.js extension functions. Webpack doesn\'t seem to like it if we modify the THREE object directly.\r\nvar THREEx = { Math: {} };\r\n/**\r\n * Returns the angle in radians of the vector (p1,p2). In other words, imagine\r\n * putting the base of the vector at coordinates (0,0) and finding the angle\r\n * from vector (1,0) to (p1,p2).\r\n * @param  {Object} p1 start point of the vector\r\n * @param  {Object} p2 end point of the vector\r\n * @return {Number} the angle\r\n */\r\nTHREEx.Math.angle2 = function(p1, p2) {\r\n\tvar v1 = new external_THREE_["Vector2"](p1.x, p1.y);\r\n\tvar v2 = new external_THREE_["Vector2"](p2.x, p2.y);\r\n\tv2.sub(v1); // sets v2 to be our chord\r\n\tv2.normalize();\r\n\tif(v2.y < 0) return -Math.acos(v2.x);\r\n\treturn Math.acos(v2.x);\r\n};\r\n\r\n\r\nTHREEx.Math.polar = function(point, distance, angle) {\r\n\tvar result = {};\r\n\tresult.x = point.x + distance * Math.cos(angle);\r\n\tresult.y = point.y + distance * Math.sin(angle);\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Calculates points for a curve between two points\r\n * @param startPoint - the starting point of the curve\r\n * @param endPoint - the ending point of the curve\r\n * @param bulge - a value indicating how much to curve\r\n * @param segments - number of segments between the two given points\r\n */\r\nTHREEx.BulgeGeometry = function ( startPoint, endPoint, bulge, segments ) {\r\n\r\n\tvar vertex, i,\r\n\t\tcenter, p0, p1, angle,\r\n\t\tradius, startAngle,\r\n\t\tthetaAngle;\r\n\r\n\texternal_THREE_["Geometry"].call( this );\r\n\r\n\tthis.startPoint = p0 = startPoint ? new external_THREE_["Vector2"](startPoint.x, startPoint.y) : new external_THREE_["Vector2"](0,0);\r\n\tthis.endPoint = p1 = endPoint ? new external_THREE_["Vector2"](endPoint.x, endPoint.y) : new external_THREE_["Vector2"](1,0);\r\n\tthis.bulge = bulge = bulge || 1;\r\n\r\n\tangle = 4 * Math.atan(bulge);\r\n\tradius = p0.distanceTo(p1) / 2 / Math.sin(angle/2);\r\n\tcenter = THREEx.Math.polar(startPoint, radius, THREEx.Math.angle2(p0,p1) + (Math.PI / 2 - angle/2));\r\n\r\n\tthis.segments = segments = segments || Math.max( Math.abs(Math.ceil(angle/(Math.PI/18))), 6); // By default want a segment roughly every 10 degrees\r\n\tstartAngle = THREEx.Math.angle2(center, p0);\r\n\tthetaAngle = angle / segments;\r\n\r\n\r\n\tthis.vertices.push(new external_THREE_["Vector3"](p0.x, p0.y, 0));\r\n\r\n\tfor(i = 1; i <= segments - 1; i++) {\r\n\r\n\t\tvertex = THREEx.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);\r\n\r\n\t\tthis.vertices.push(new external_THREE_["Vector3"](vertex.x, vertex.y, 0));\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREEx.BulgeGeometry.prototype = Object.create( external_THREE_["Geometry"].prototype );\r\n    \r\n/**\r\n * Viewer class for a dxf object.\r\n * @param {Object} data - the dxf object\r\n * @param {Object} parent - the parent element to which we attach the rendering canvas\r\n * @param {Number} width - width of the rendering canvas in pixels\r\n * @param {Number} height - height of the rendering canvas in pixels\r\n * @param {Object} font - a font loaded with THREE.FontLoader \r\n * @constructor\r\n */\r\nfunction Viewer(data, parent, width, height, font) {\r\n\r\n    createLineTypeShaders(data);\r\n\r\n    var scene = new external_THREE_["Scene"]();\r\n\r\n    // Create scene from dxf object (data)\r\n    var i, entity, obj, min_x, min_y, min_z, max_x, max_y, max_z;\r\n    var dims = {\r\n        min: { x: false, y: false, z: false},\r\n        max: { x: false, y: false, z: false}\r\n    };\r\n    for(i = 0; i < data.entities.length; i++) {\r\n        entity = data.entities[i];\r\n        obj = drawEntity(entity, data);\r\n\r\n        if (obj) {\r\n            var bbox = new external_THREE_["Box3"]().setFromObject(obj);\r\n            if (bbox.min.x && ((dims.min.x === false) || (dims.min.x > bbox.min.x))) dims.min.x = bbox.min.x;\r\n            if (bbox.min.y && ((dims.min.y === false) || (dims.min.y > bbox.min.y))) dims.min.y = bbox.min.y;\r\n            if (bbox.min.z && ((dims.min.z === false) || (dims.min.z > bbox.min.z))) dims.min.z = bbox.min.z;\r\n            if (bbox.max.x && ((dims.max.x === false) || (dims.max.x < bbox.max.x))) dims.max.x = bbox.max.x;\r\n            if (bbox.max.y && ((dims.max.y === false) || (dims.max.y < bbox.max.y))) dims.max.y = bbox.max.y;\r\n            if (bbox.max.z && ((dims.max.z === false) || (dims.max.z < bbox.max.z))) dims.max.z = bbox.max.z;\r\n            scene.add(obj);\r\n        }\r\n        obj = null;\r\n    }\r\n\r\n    width = width || parent.innerWidth;\r\n    height = height || parent.innerHeight;\r\n    var aspectRatio = width / height;\r\n\r\n    var upperRightCorner = { x: dims.max.x, y: dims.max.y };\r\n    var lowerLeftCorner = { x: dims.min.x, y: dims.min.y };\r\n\r\n    // Figure out the current viewport extents\r\n    var vp_width = upperRightCorner.x - lowerLeftCorner.x;\r\n    var vp_height = upperRightCorner.y - lowerLeftCorner.y;\r\n    var center = center || {\r\n        x: vp_width / 2 + lowerLeftCorner.x,\r\n        y: vp_height / 2 + lowerLeftCorner.y\r\n    };\r\n\r\n    // Fit all objects into current ThreeDXF viewer\r\n    var extentsAspectRatio = Math.abs(vp_width / vp_height);\r\n    if (aspectRatio > extentsAspectRatio) {\r\n        vp_width = vp_height * aspectRatio;\r\n    } else {\r\n        vp_height = vp_width / aspectRatio;\r\n    }\r\n    \r\n    var viewPort = {\r\n        bottom: -vp_height / 2,\r\n        left: -vp_width / 2,\r\n        top: vp_height / 2,\r\n        right: vp_width / 2,\r\n        center: {\r\n            x: center.x,\r\n            y: center.y\r\n        }\r\n    };\r\n\r\n    var camera = new external_THREE_["OrthographicCamera"](viewPort.left, viewPort.right, viewPort.top, viewPort.bottom, 1, 19);\r\n    camera.position.z = 10;\r\n    camera.position.x = viewPort.center.x;\r\n    camera.position.y = viewPort.center.y;\r\n\r\n    var renderer = this.renderer = new external_THREE_["WebGLRenderer"]();\r\n    renderer.setSize(width, height);\r\n    renderer.setClearColor(0xfffffff, 1);\r\n\r\n    parent.appendChild(renderer.domElement);\r\n    parent.style.display = \'block\';\r\n\r\n    //TODO: Need to make this an option somehow so others can roll their own controls.\r\n    var controls = new OrbitControls(camera, parent);\r\n    controls.target.x = camera.position.x;\r\n    controls.target.y = camera.position.y;\r\n    controls.target.z = 0;\r\n    controls.zoomSpeed = 3;\r\n\r\n    //Uncomment this to disable rotation (does not make much sense with 2D drawings).\r\n    //controls.enableRotate = false;\r\n\r\n    this.render = function() { renderer.render(scene, camera) };\r\n    controls.addEventListener(\'change\', this.render);\r\n    this.render();\r\n    controls.update();\r\n\r\n    this.resize = function(width, height) {\r\n        var originalWidth = renderer.domElement.width;\r\n        var originalHeight = renderer.domElement.height;\r\n\r\n        var hscale = width / originalWidth;\r\n        var vscale = height / originalHeight;\r\n\r\n\r\n        camera.top = (vscale * camera.top);\r\n        camera.bottom = (vscale * camera.bottom);\r\n        camera.left = (hscale * camera.left);\r\n        camera.right = (hscale * camera.right);\r\n\r\n//        camera.updateProjectionMatrix();\r\n\r\n        renderer.setSize(width, height);\r\n        renderer.setClearColor(0xfffffff, 1);\r\n        this.render();\r\n    };\r\n\r\n    function drawEntity(entity, data) {\r\n        var mesh;\r\n        if(entity.type === \'CIRCLE\' || entity.type === \'ARC\') {\r\n            mesh = drawArc(entity, data);\r\n        } else if(entity.type === \'LWPOLYLINE\' || entity.type === \'LINE\' || entity.type === \'POLYLINE\') {\r\n            mesh = drawLine(entity, data);\r\n        } else if(entity.type === \'TEXT\') {\r\n            mesh = drawText(entity, data);\r\n        } else if(entity.type === \'SOLID\') {\r\n            mesh = drawSolid(entity, data);\r\n        } else if(entity.type === \'POINT\') {\r\n            mesh = drawPoint(entity, data);\r\n        } else if(entity.type === \'INSERT\') {\r\n            mesh = drawBlock(entity, data);\r\n        } else if(entity.type === \'SPLINE\') {\r\n            mesh = drawSpline(entity, data);\r\n        } else if(entity.type === \'MTEXT\') {\r\n            mesh = drawMtext(entity, data);\r\n        } else if(entity.type === \'ELLIPSE\') {\r\n            mesh = drawEllipse(entity, data);\r\n        } else if(entity.type === \'DIMENSION\') {\r\n            var dimTypeEnum = entity.dimensionType & 7;\r\n            if(dimTypeEnum === 0) {\r\n                mesh = drawDimension(entity, data);\r\n            } else {\r\n                console.log("Unsupported Dimension type: " + dimTypeEnum);\r\n            }\r\n        }\r\n        else {\r\n            console.log("Unsupported Entity Type: " + entity.type);\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    function drawEllipse(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x,2) + Math.pow(entity.majorAxisEndPoint.y,2));\r\n        var yrad = xrad*entity.axisRatio;\r\n        var rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);\r\n\r\n        var curve = new external_THREE_["EllipseCurve"](\r\n            entity.center.x,  entity.center.y,\r\n            xrad, yrad,\r\n            entity.startAngle, entity.endAngle,\r\n            false, // Always counterclockwise\r\n            rotation\r\n        );\r\n\r\n        var points = curve.getPoints( 50 );\r\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( points );\r\n        var material = new external_THREE_["LineBasicMaterial"]( {  linewidth: 1, color : color } );\r\n\r\n        // Create the final object to add to the scene\r\n        var ellipse = new external_THREE_["Line"]( geometry, material );\r\n        return ellipse;\r\n    }\r\n\r\n    function drawMtext(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var geometry = new external_THREE_["TextGeometry"]( entity.text, {\r\n            font: font,\r\n            size: entity.height * (4/5),\r\n            height: 1\r\n        });\r\n        var material = new external_THREE_["MeshBasicMaterial"]( {color: color} );\r\n        var text = new external_THREE_["Mesh"]( geometry, material );\r\n\r\n        // Measure what we rendered.\r\n        var measure = new external_THREE_["Box3"]();\r\n        measure.setFromObject( text );\r\n\r\n        var textWidth  = measure.max.x - measure.min.x;\r\n\r\n        // If the text ends up being wider than the box, it\'s supposed\r\n        // to be multiline. Doing that in threeJS is overkill.\r\n        if (textWidth > entity.width) {\r\n            console.log("Can\'t render this multipline MTEXT entity, sorry.", entity);\r\n            return undefined;\r\n        }\r\n\r\n        text.position.z = 0;\r\n        switch (entity.attachmentPoint) {\r\n            case 1:\r\n                // Top Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 2:\r\n                // Top Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n            case 3:\r\n                // Top Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height;\r\n            break;\r\n\r\n            case 4:\r\n                // Middle Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 5:\r\n                // Middle Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n            case 6:\r\n                // Middle Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y - entity.height/2;\r\n            break;\r\n\r\n            case 7:\r\n                // Bottom Left\r\n                text.position.x = entity.position.x;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 8:\r\n                // Bottom Center\r\n                text.position.x = entity.position.x - textWidth/2;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n            case 9:\r\n                // Bottom Right\r\n                text.position.x = entity.position.x - textWidth;\r\n                text.position.y = entity.position.y;\r\n            break;\r\n\r\n            default:\r\n                return undefined;\r\n        };\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawSpline(entity, data) {\r\n        var color = getColor(entity, data);\r\n\r\n        var points = entity.controlPoints.map(function(vec) {\r\n            return new external_THREE_["Vector2"](vec.x, vec.y);\r\n        });\r\n\r\n        var interpolatedPoints = [];\r\n        var curve;\r\n        if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {\r\n            for(var i = 0; i + 2 < points.length; i = i + 2) {\r\n        if (entity.degreeOfSplineCurve === 2) {\r\n                        curve = new external_THREE_["QuadraticBezierCurve"](points[i], points[i + 1], points[i + 2]);\r\n        } else {\r\n            curve = new external_THREE_["QuadraticBezierCurve3"](points[i], points[i + 1], points[i + 2]);\r\n        }\r\n                interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));\r\n            }\r\n        } else {\r\n            curve = new external_THREE_["SplineCurve"](points);\r\n            interpolatedPoints = curve.getPoints( 100 );\r\n        }\r\n\r\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( interpolatedPoints );\r\n        var material = new external_THREE_["LineBasicMaterial"]( { linewidth: 1, color : color } );\r\n        var splineObject = new external_THREE_["Line"]( geometry, material );\r\n\r\n        return splineObject;\r\n    }\r\n\r\n    function drawLine(entity, data) {\r\n        var geometry = new external_THREE_["Geometry"](),\r\n            color = getColor(entity, data),\r\n            material, lineType, vertex, startPoint, endPoint, bulgeGeometry,\r\n            bulge, i, line;\r\n\r\n        // create geometry\r\n        for(i = 0; i < entity.vertices.length; i++) {\r\n\r\n            if(entity.vertices[i].bulge) {\r\n                bulge = entity.vertices[i].bulge;\r\n                startPoint = entity.vertices[i];\r\n                endPoint = i + 1 < entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];\r\n\r\n                bulgeGeometry = new THREEx.BulgeGeometry(startPoint, endPoint, bulge);\r\n\r\n                geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);\r\n            } else {\r\n                vertex = entity.vertices[i];\r\n                geometry.vertices.push(new external_THREE_["Vector3"](vertex.x, vertex.y, 0));\r\n            }\r\n\r\n        }\r\n        if(entity.shape) geometry.vertices.push(geometry.vertices[0]);\r\n\r\n\r\n        // set material\r\n        if(entity.lineType) {\r\n            lineType = data.tables.lineType.lineTypes[entity.lineType];\r\n        }\r\n\r\n        if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n            material = new external_THREE_["LineDashedMaterial"]({ color: color, gapSize: 4, dashSize: 4});\r\n        } else {\r\n            material = new external_THREE_["LineBasicMaterial"]({ linewidth: 1, color: color });\r\n        }\r\n\r\n        // if(lineType && lineType.pattern && lineType.pattern.length !== 0) {\r\n\r\n        //           geometry.computeLineDistances();\r\n\r\n        //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we\r\n        //           // don\'t add diffuse to a material.\r\n        //           lineType.material.uniforms.diffuse = { type: \'c\', value: new THREE.Color(color) };\r\n\r\n        // \tmaterial = new THREE.ShaderMaterial({\r\n        // \t\tuniforms: lineType.material.uniforms,\r\n        // \t\tvertexShader: lineType.material.vertexShader,\r\n        // \t\tfragmentShader: lineType.material.fragmentShader\r\n        // \t});\r\n        // }else {\r\n        // \tmaterial = new THREE.LineBasicMaterial({ linewidth: 1, color: color });\r\n        // }\r\n\r\n        line = new external_THREE_["Line"](geometry, material);\r\n        return line;\r\n    }\r\n    \r\n    function drawArc(entity, data) {\r\n        var startAngle, endAngle;\r\n        if (entity.type === \'CIRCLE\') {\r\n            startAngle = entity.startAngle || 0;\r\n            endAngle = startAngle + 2 * Math.PI;\r\n        } else {\r\n            startAngle = entity.startAngle;\r\n            endAngle = entity.endAngle;\r\n        }\r\n\r\n        var curve = new external_THREE_["ArcCurve"](\r\n            0, 0,\r\n            entity.radius,\r\n            startAngle,\r\n            endAngle);\r\n\r\n        var points = curve.getPoints( 32 );\r\n        var geometry = new external_THREE_["BufferGeometry"]().setFromPoints( points );\r\n\r\n        var material = new external_THREE_["LineBasicMaterial"]({ color: getColor(entity, data) });\r\n\r\n        var arc = new external_THREE_["Line"](geometry, material);\r\n        arc.position.x = entity.center.x;\r\n        arc.position.y = entity.center.y;\r\n        arc.position.z = entity.center.z;\r\n\r\n        return arc;\r\n    }\r\n\r\n    function drawSolid(entity, data) {\r\n        var material, mesh, verts,\r\n            geometry = new external_THREE_["Geometry"]();\r\n\r\n        verts = geometry.vertices;\r\n        verts.push(new external_THREE_["Vector3"](entity.points[0].x, entity.points[0].y, entity.points[0].z));\r\n        verts.push(new external_THREE_["Vector3"](entity.points[1].x, entity.points[1].y, entity.points[1].z));\r\n        verts.push(new external_THREE_["Vector3"](entity.points[2].x, entity.points[2].y, entity.points[2].z));\r\n        verts.push(new external_THREE_["Vector3"](entity.points[3].x, entity.points[3].y, entity.points[3].z));\r\n\r\n        // Calculate which direction the points are facing (clockwise or counter-clockwise)\r\n        var vector1 = new external_THREE_["Vector3"]();\r\n        var vector2 = new external_THREE_["Vector3"]();\r\n        vector1.subVectors(verts[1], verts[0]);\r\n        vector2.subVectors(verts[2], verts[0]);\r\n        vector1.cross(vector2);\r\n\r\n        // If z < 0 then we must draw these in reverse order\r\n        if(vector1.z < 0) {\r\n            geometry.faces.push(new external_THREE_["Face3"](2, 1, 0));\r\n            geometry.faces.push(new external_THREE_["Face3"](2, 3, 1));\r\n        } else {\r\n            geometry.faces.push(new external_THREE_["Face3"](0, 1, 2));\r\n            geometry.faces.push(new external_THREE_["Face3"](1, 3, 2));\r\n        }\r\n\r\n\r\n        material = new external_THREE_["MeshBasicMaterial"]({ color: getColor(entity, data) });\r\n\r\n        return new external_THREE_["Mesh"](geometry, material);\r\n        \r\n    }\r\n\r\n    function drawText(entity, data) {\r\n        var geometry, material, text;\r\n\r\n        if(!font)\r\n            return console.warn(\'Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.\');\r\n        \r\n        geometry = new external_THREE_["TextGeometry"](entity.text, { font: font, height: 0, size: entity.textHeight || 12 });\r\n\r\n        if (entity.rotation) {\r\n            var zRotation = entity.rotation * Math.PI / 180;\r\n            geometry.rotateZ(zRotation);\r\n        }\r\n\r\n        material = new external_THREE_["MeshBasicMaterial"]({ color: getColor(entity, data) });\r\n\r\n        text = new external_THREE_["Mesh"](geometry, material);\r\n        text.position.x = entity.startPoint.x;\r\n        text.position.y = entity.startPoint.y;\r\n        text.position.z = entity.startPoint.z;\r\n\r\n        return text;\r\n    }\r\n\r\n    function drawPoint(entity, data) {\r\n        var geometry, material, point;\r\n\r\n        geometry = new external_THREE_["Geometry"]();\r\n\r\n        geometry.vertices.push(new external_THREE_["Vector3"](entity.position.x, entity.position.y, entity.position.z));\r\n\r\n        // TODO: could be more efficient. PointCloud per layer?\r\n\r\n        var numPoints = 1;\r\n\r\n        var color = getColor(entity, data);\r\n        var colors = new Float32Array( numPoints*3 );\r\n        colors[0] = color.r;\r\n        colors[1] = color.g;\r\n        colors[2] = color.b;\r\n\r\n        geometry.colors = colors;\r\n        geometry.computeBoundingBox();\r\n\r\n        material = new external_THREE_["PointsMaterial"]( { size: 0.05, vertexColors: external_THREE_["VertexColors"] } );\r\n        point = new external_THREE_["Points"](geometry, material);\r\n        scene.add(point);\r\n    }\r\n\r\n    function drawDimension(entity, data) {\r\n        var block = data.blocks[entity.block];\r\n\r\n        if (!block || !block.entities) return null;\r\n\r\n        var group = new external_THREE_["Object3D"]();\r\n        // if(entity.anchorPoint) {\r\n        //     group.position.x = entity.anchorPoint.x;\r\n        //     group.position.y = entity.anchorPoint.y;\r\n        //     group.position.z = entity.anchorPoint.z;\r\n        // }\r\n\r\n        for(var i = 0; i < block.entities.length; i++) {\r\n            var childEntity = drawEntity(block.entities[i], data, group);\r\n            if(childEntity) group.add(childEntity);\r\n        }\r\n\r\n        return group;\r\n    }\r\n\r\n    function drawBlock(entity, data) {\r\n        var block = data.blocks[entity.name];\r\n        \r\n        if (!block.entities) return null;\r\n\r\n        var group = new external_THREE_["Object3D"]()\r\n        \r\n        if(entity.xScale) group.scale.x = entity.xScale;\r\n        if(entity.yScale) group.scale.y = entity.yScale;\r\n\r\n        if(entity.rotation) {\r\n            group.rotation.z = entity.rotation * Math.PI / 180;\r\n        }\r\n\r\n        if(entity.position) {\r\n            group.position.x = entity.position.x;\r\n            group.position.y = entity.position.y;\r\n            group.position.z = entity.position.z;\r\n        }\r\n        \r\n        for(var i = 0; i < block.entities.length; i++) {\r\n            var childEntity = drawEntity(block.entities[i], data, group);\r\n            if(childEntity) group.add(childEntity);\r\n        }\r\n\r\n        return group;\r\n    }\r\n\r\n    function getColor(entity, data) {\r\n        var color = 0x000000; //default\r\n        if(entity.color) color = entity.color;\r\n        else if(data.tables && data.tables.layer && data.tables.layer.layers[entity.layer])\r\n            color = data.tables.layer.layers[entity.layer].color;\r\n            \r\n        if(color == null || color === 0xffffff) {\r\n            color = 0x000000;\r\n        }\r\n        return color;\r\n    }\r\n\r\n    function createLineTypeShaders(data) {\r\n        var ltype, type;\r\n        if(!data.tables || !data.tables.lineType) return;\r\n        var ltypes = data.tables.lineType.lineTypes;\r\n\r\n        for(type in ltypes) {\r\n            ltype = ltypes[type];\r\n            if(!ltype.pattern) continue;\r\n            ltype.material = createDashedLineShader(ltype.pattern);\r\n        }\r\n    }\r\n\r\n    function createDashedLineShader(pattern) {\r\n        var i,\r\n            dashedLineShader = {},\r\n            totalLength = 0.0;\r\n\r\n        for(i = 0; i < pattern.length; i++) {\r\n            totalLength += Math.abs(pattern[i]);\r\n        }\r\n\r\n        dashedLineShader.uniforms = external_THREE_["UniformsUtils"].merge([\r\n\r\n            external_THREE_["UniformsLib"][ \'common\' ],\r\n            external_THREE_["UniformsLib"][ \'fog\' ],\r\n\r\n            {\r\n                \'pattern\': { type: \'fv1\', value: pattern },\r\n                \'patternLength\': { type: \'f\', value: totalLength }\r\n            }\r\n\r\n        ]);\r\n\r\n        dashedLineShader.vertexShader = [\r\n            \'attribute float lineDistance;\',\r\n\r\n            \'varying float vLineDistance;\',\r\n\r\n            external_THREE_["ShaderChunk"][ \'color_pars_vertex\' ],\r\n\r\n            \'void main() {\',\r\n\r\n            external_THREE_["ShaderChunk"][ \'color_vertex\' ],\r\n\r\n            \'vLineDistance = lineDistance;\',\r\n\r\n            \'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\',\r\n\r\n            \'}\'\r\n        ].join(\'\\n\');\r\n\r\n        dashedLineShader.fragmentShader = [\r\n            \'uniform vec3 diffuse;\',\r\n            \'uniform float opacity;\',\r\n\r\n            \'uniform float pattern[\' + pattern.length + \'];\',\r\n            \'uniform float patternLength;\',\r\n\r\n            \'varying float vLineDistance;\',\r\n\r\n            external_THREE_["ShaderChunk"][ \'color_pars_fragment\' ],\r\n            external_THREE_["ShaderChunk"][ \'fog_pars_fragment\' ],\r\n\r\n            \'void main() {\',\r\n\r\n            \'float pos = mod(vLineDistance, patternLength);\',\r\n\r\n            \'for ( int i = 0; i < \' + pattern.length + \'; i++ ) {\',\r\n            \'pos = pos - abs(pattern[i]);\',\r\n            \'if( pos < 0.0 ) {\',\r\n            \'if( pattern[i] > 0.0 ) {\',\r\n            \'gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );\',\r\n            \'break;\',\r\n            \'}\',\r\n            \'discard;\',\r\n            \'}\',\r\n\r\n            \'}\',\r\n\r\n            external_THREE_["ShaderChunk"][ \'color_fragment\' ],\r\n            external_THREE_["ShaderChunk"][ \'fog_fragment\' ],\r\n\r\n            \'}\'\r\n        ].join(\'\\n\');\r\n\r\n        return dashedLineShader;\r\n    }\r\n\r\n    function findExtents(scene) { \r\n        for(var child of scene.children) {\r\n            var minX, maxX, minY, maxY;\r\n            if(child.position) {\r\n                minX = Math.min(child.position.x, minX);\r\n                minY = Math.min(child.position.y, minY);\r\n                maxX = Math.max(child.position.x, maxX);\r\n                maxY = Math.max(child.position.y, maxY);\r\n            }\r\n        }\r\n\r\n        return { min: { x: minX, y: minY }, max: { x: maxX, y: maxY }};\r\n    }\r\n\r\n}\r\n\r\n\r\n// Show/Hide helpers from https://plainjs.com/javascript/effects/hide-or-show-an-element-42/\r\n// get the default display style of an element\r\nfunction defaultDisplay(tag) {\r\n    var iframe = document.createElement(\'iframe\');\r\n    iframe.setAttribute(\'frameborder\', 0);\r\n    iframe.setAttribute(\'width\', 0);\r\n    iframe.setAttribute(\'height\', 0);\r\n    document.documentElement.appendChild(iframe);\r\n\r\n    var doc = (iframe.contentWindow || iframe.contentDocument).document;\r\n\r\n    // IE support\r\n    doc.write();\r\n    doc.close();\r\n\r\n    var testEl = doc.createElement(tag);\r\n    doc.documentElement.appendChild(testEl);\r\n    var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display\r\n    iframe.parentNode.removeChild(iframe);\r\n    return display;\r\n}\r\n\r\n// actual show/hide function used by show() and hide() below\r\nfunction showHide(el, show) {\r\n    var value = el.getAttribute(\'data-olddisplay\'),\r\n    display = el.style.display,\r\n    computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display;\r\n\r\n    if (show) {\r\n        if (!value && display === \'none\') el.style.display = \'\';\r\n        if (el.style.display === \'\' && (computedDisplay === \'none\')) value = value || defaultDisplay(el.nodeName);\r\n    } else {\r\n        if (display && display !== \'none\' || !(computedDisplay == \'none\'))\r\n            el.setAttribute(\'data-olddisplay\', (computedDisplay == \'none\') ? display : computedDisplay);\r\n    }\r\n    if (!show || el.style.display === \'none\' || el.style.display === \'\')\r\n        el.style.display = show ? value || \'\' : \'none\';\r\n}\r\n\r\n// helper functions\r\nfunction show(el) { showHide(el, true); }\r\nfunction hide(el) { showHide(el); }\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UaHJlZUR4Zi8uL3NyYy9PcmJpdENvbnRyb2xzLmpzP2UyMGYiLCJ3ZWJwYWNrOi8vVGhyZWVEeGYvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjs7QUFFeEI7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQWE7O0FBRWhDLDhCQUE4QjtBQUM5Qjs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUFhO0FBQ3BDLHFCQUFxQiwwQkFBYTtBQUNsQyx1QkFBdUIsMEJBQWE7O0FBRXBDLG9CQUFvQiwwQkFBYTtBQUNqQyxrQkFBa0IsMEJBQWE7QUFDL0Isb0JBQW9CLDBCQUFhO0FBQ2pDLHFCQUFxQiwwQkFBYTs7QUFFbEMsa0JBQWtCLDBCQUFhOztBQUUvQixzQkFBc0IsMEJBQWE7QUFDbkMsb0JBQW9CLDBCQUFhO0FBQ2pDLHNCQUFzQiwwQkFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBYTs7QUFFNUIsd0JBQXdCLDBCQUFhOztBQUVyQyxjQUFjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBLEdBQUcseUNBQXlDOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0VBQXNF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O0FBQzFELG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxZQUFZLDhCQUFpQjtBQUM3QixZQUFZLDhCQUFpQjs7QUFFN0IsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU8sbUJBQW1CLFFBQVE7QUFDbEQ7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixjQUFjIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBlcmljaDY2NiAvIGh0dHA6Ly9lcmljaGFpbmVzLmNvbVxyXG4gKi9cclxuLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cclxuXHJcbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLiBJdCBtYWludGFpbnNcclxuLy8gdGhlIFwidXBcIiBkaXJlY3Rpb24gYXMgK1ksIHVubGlrZSB0aGUgVHJhY2tiYWxsQ29udHJvbHMuIFRvdWNoIG9uIHRhYmxldCBhbmQgcGhvbmVzIGlzXHJcbi8vIHN1cHBvcnRlZC5cclxuLy9cclxuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxyXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxyXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW50ZXIgc3dpcGVcclxuLy9cclxuLy8gVGhpcyBpcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIChtb3N0KSBUcmFja2JhbGxDb250cm9scyB1c2VkIGluIGV4YW1wbGVzLlxyXG4vLyBUaGF0IGlzLCBpbmNsdWRlIHRoaXMganMgZmlsZSBhbmQgd2hlcmV2ZXIgeW91IHNlZTpcclxuLy8gICAgXHRjb250cm9scyA9IG5ldyBUSFJFRS5UcmFja2JhbGxDb250cm9scyggY2FtZXJhICk7XHJcbi8vICAgICAgY29udHJvbHMudGFyZ2V0LnogPSAxNTA7XHJcbi8vIFNpbXBsZSBzdWJzdGl0dXRlIFwiT3JiaXRDb250cm9sc1wiIGFuZCB0aGUgY29udHJvbCBzaG91bGQgd29yayBhcy1pcy5cclxuXHJcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBPcmJpdENvbnRyb2xzKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XHJcblxyXG5cdC8vIEFQSVxyXG5cclxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuXHQvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgY29udHJvbCBvcmJpdHMgYXJvdW5kXHJcblx0Ly8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Ly8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxyXG5cdHRoaXMuY2VudGVyID0gdGhpcy50YXJnZXQ7XHJcblxyXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3JcclxuXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdHRoaXMubm9ab29tID0gZmFsc2U7XHJcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XHJcblxyXG5cdC8vIExpbWl0cyB0byBob3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dFxyXG5cdHRoaXMubWluRGlzdGFuY2UgPSAwO1xyXG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLm5vUm90YXRlID0gZmFsc2U7XHJcblx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcclxuXHR0aGlzLm5vUGFuID0gZmFsc2U7XHJcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcclxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcclxuXHJcblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXHJcblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXHJcblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xyXG5cdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB1c2Ugb2YgdGhlIGtleXNcclxuXHR0aGlzLm5vS2V5cyA9IGZhbHNlO1xyXG5cclxuXHQvLyBUaGUgZm91ciBhcnJvdyBrZXlzXHJcblx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcclxuXHJcblx0Ly8vLy8vLy8vLy8vXHJcblx0Ly8gaW50ZXJuYWxzXHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcclxuXHJcblx0dmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBwYW5EZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdHZhciBwaGlEZWx0YSA9IDA7XHJcblx0dmFyIHRoZXRhRGVsdGEgPSAwO1xyXG5cdHZhciBzY2FsZSA9IDE7XHJcblx0dmFyIHBhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR2YXIgU1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgRE9MTFkgOiAxLCBQQU4gOiAyLCBUT1VDSF9ST1RBVEUgOiAzLCBUT1VDSF9ET0xMWSA6IDQsIFRPVUNIX1BBTiA6IDUgfTtcclxuXHJcblx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0Ly8gZm9yIHJlc2V0XHJcblxyXG5cdHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XHJcblx0dGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xyXG5cclxuXHQvLyBldmVudHNcclxuXHJcblx0dmFyIGNoYW5nZUV2ZW50ID0geyB0eXBlOiAnY2hhbmdlJyB9O1xyXG5cdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnfTtcclxuXHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnfTtcclxuXHJcblx0dGhpcy5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcblx0XHRpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoZXRhRGVsdGEgLT0gYW5nbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cGhpRGVsdGEgLT0gYW5nbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSBsZWZ0XHJcblx0dGhpcy5wYW5MZWZ0ID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Ly8gZ2V0IFggY29sdW1uIG9mIG1hdHJpeFxyXG5cdFx0cGFuT2Zmc2V0LnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xyXG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XHJcblx0XHRcclxuXHRcdHBhbi5hZGQoIHBhbk9mZnNldCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgdXBcclxuXHR0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0Ly8gZ2V0IFkgY29sdW1uIG9mIG1hdHJpeFxyXG5cdFx0cGFuT2Zmc2V0LnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xyXG5cdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xyXG5cdFx0XHJcblx0XHRwYW4uYWRkKCBwYW5PZmZzZXQgKTtcclxuXHJcblx0fTtcclxuXHRcclxuXHQvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcclxuXHQvLyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcclxuXHR0aGlzLnBhbiA9IGZ1bmN0aW9uICggZGVsdGFYLCBkZWx0YVkgKSB7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuZm92ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBwZXJzcGVjdGl2ZVxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwb3NpdGlvbi5jbG9uZSgpLnN1Yiggc2NvcGUudGFyZ2V0ICk7XHJcblx0XHRcdHZhciB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcclxuXHJcblx0XHRcdC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxyXG5cdFx0XHR0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XHJcblxyXG5cdFx0XHQvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XHJcblx0XHRcdHNjb3BlLnBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XHJcblx0XHRcdHNjb3BlLnBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC50b3AgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgXHJcblx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xyXG5cdFx0XHRzY29wZS5wYW5MZWZ0KCBkZWx0YVggKiAoc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQpIC8gZWxlbWVudC5jbGllbnRXaWR0aCApO1xyXG5cdFx0XHRzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBvciBwZXJzcGVjdGl2ZVxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5kb2xseUluID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xyXG5cclxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmRvbGx5T3V0ID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xyXG5cclxuXHRcdGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZSAqPSBkb2xseVNjYWxlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZihzY29wZS5vYmplY3QudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vYmplY3QudG9wID0gKHNjYWxlKnRoaXMub2JqZWN0LnRvcCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmJvdHRvbSA9IChzY2FsZSp0aGlzLm9iamVjdC5ib3R0b20pO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5sZWZ0ID0gKHNjYWxlKnRoaXMub2JqZWN0LmxlZnQpO1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5yaWdodCA9IChzY2FsZSp0aGlzLm9iamVjdC5yaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5vYmplY3QucG9zaXRpb247XHJcblxyXG5cdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCB0aGlzLnRhcmdldCApO1xyXG4vL1xyXG4vL1x0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXHJcbi8vXHJcbi8vXHRcdHZhciB0aGV0YSA9IE1hdGguYXRhbjIoIG9mZnNldC54LCBvZmZzZXQueiApO1xyXG4vL1xyXG4vL1x0XHQvLyBhbmdsZSBmcm9tIHktYXhpc1xyXG4vL1xyXG4vL1x0XHR2YXIgcGhpID0gTWF0aC5hdGFuMiggTWF0aC5zcXJ0KCBvZmZzZXQueCAqIG9mZnNldC54ICsgb2Zmc2V0LnogKiBvZmZzZXQueiApLCBvZmZzZXQueSApO1xyXG4vL1xyXG4vL1x0XHRpZiAoIHRoaXMuYXV0b1JvdGF0ZSApIHtcclxuLy9cclxuLy9cdFx0XHR0aGlzLnJvdGF0ZUxlZnQoIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkgKTtcclxuLy9cclxuLy9cdFx0fVxyXG4vL1xyXG4vL1x0XHR0aGV0YSArPSB0aGV0YURlbHRhO1xyXG4vL1x0XHRwaGkgKz0gcGhpRGVsdGE7XHJcbi8vXHJcbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXHJcbi8vXHRcdHBoaSA9IE1hdGgubWF4KCB0aGlzLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCB0aGlzLm1heFBvbGFyQW5nbGUsIHBoaSApICk7XHJcbi8vXHJcbi8vXHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcclxuLy9cdFx0cGhpID0gTWF0aC5tYXgoIEVQUywgTWF0aC5taW4oIE1hdGguUEkgLSBFUFMsIHBoaSApICk7XHJcbi8vXHJcbi8vXHRcdHZhciByYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCkgKiBzY2FsZTtcclxuLy9cclxuLy9cdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcclxuLy9cdFx0cmFkaXVzID0gTWF0aC5tYXgoIHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKCB0aGlzLm1heERpc3RhbmNlLCByYWRpdXMgKSApO1xyXG4vL1x0XHRcclxuLy9cdFx0Ly8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXHJcblx0XHR0aGlzLnRhcmdldC5hZGQoIHBhbiApO1xyXG4vL1x0XHRcclxuLy9cdFx0b2Zmc2V0LnggPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpICkgKiBNYXRoLnNpbiggdGhldGEgKTtcclxuLy9cdFx0b2Zmc2V0LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggcGhpICk7XHJcbi8vXHRcdG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XHJcbi8vXHJcblx0XHRwb3NpdGlvbi5jb3B5KCB0aGlzLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0dGhpcy5vYmplY3QubG9va0F0KCB0aGlzLnRhcmdldCApO1xyXG5cclxuXHJcbi8vXHRcdGlmICggbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG8oIHRoaXMub2JqZWN0LnBvc2l0aW9uICkgPiAwIHx8IHNjYWxlICE9PSAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xyXG5cclxuLy9cdFx0XHRsYXN0UG9zaXRpb24uY29weSggdGhpcy5vYmplY3QucG9zaXRpb24gKTtcclxuXHJcbi8vXHRcdH1cclxuICAgICAgICBcclxuLy8gICAgICAgIHRoZXRhRGVsdGEgPSAwO1xyXG4vL1x0XHRwaGlEZWx0YSA9IDA7XHJcblx0XHRzY2FsZSA9IDE7XHJcblx0XHRwYW4uc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0XHR0aGlzLnRhcmdldC5jb3B5KCB0aGlzLnRhcmdldDAgKTtcclxuXHRcdHRoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHRoaXMucG9zaXRpb24wICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0aWYgKCBldmVudC5idXR0b24gPT09IDAgKSB7XHJcblx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcclxuXHJcblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMSApIHtcclxuXHRcdFx0aWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xyXG5cclxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDIgKSB7XHJcblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcclxuXHJcblx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcclxuXHJcblx0XHRpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XHJcblxyXG5cdFx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXHJcblx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cclxuXHRcdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXHJcblx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuRE9MTFkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRvbGx5T3V0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlBBTiApIHtcclxuXHJcblx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcclxuXHRcdFx0XHJcblx0XHRcdHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xyXG5cclxuXHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VVcCggLyogZXZlbnQgKi8gKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHR2YXIgZGVsdGEgPSAwO1xyXG5cclxuXHRcdGlmICggZXZlbnQud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcclxuXHJcblx0XHRcdGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZXRhaWwgIT09IHVuZGVmaW5lZCApIHsgLy8gRmlyZWZveFxyXG5cclxuXHRcdFx0ZGVsdGEgPSAtIGV2ZW50LmRldGFpbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkZWx0YSA+IDAgKSB7XHJcblxyXG5cdFx0XHRzY29wZS5kb2xseU91dCgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzY29wZS5kb2xseUluKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xyXG5cdFx0XHJcblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxyXG5cdFx0XHRcdHNjb3BlLnBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XHJcblx0XHRcdFx0c2NvcGUucGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcclxuXHRcdFx0XHRzY29wZS5wYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XHJcblx0XHRcdFx0c2NvcGUucGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvdWNoc3RhcnQoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDE6XHQvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcclxuXHJcblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcclxuXHJcblx0XHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xyXG5cdFx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblx0XHRcdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XHJcblxyXG5cdFx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcclxuXHJcblx0XHRcdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxyXG5cdFx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cdFx0XHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxyXG5cdFx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xyXG5cclxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ET0xMWSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0dmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xyXG5cdFx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblxyXG5cdFx0XHRcdGRvbGx5RW5kLnNldCggMCwgZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5kb2xseU91dCgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLmRvbGx5SW4oKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUEFOICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcclxuXHJcblx0XHRcdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0b3VjaGVuZCggLyogZXZlbnQgKi8gKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xyXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcclxuXHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcclxuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlICk7XHJcblx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlICk7XHJcblxyXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcclxuXHJcbn07XHJcblxyXG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTsiLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XHJcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICcuL09yYml0Q29udHJvbHMnO1xyXG5cclxuLy8gVGhyZWUuanMgZXh0ZW5zaW9uIGZ1bmN0aW9ucy4gV2VicGFjayBkb2Vzbid0IHNlZW0gdG8gbGlrZSBpdCBpZiB3ZSBtb2RpZnkgdGhlIFRIUkVFIG9iamVjdCBkaXJlY3RseS5cclxudmFyIFRIUkVFeCA9IHsgTWF0aDoge30gfTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb2YgdGhlIHZlY3RvciAocDEscDIpLiBJbiBvdGhlciB3b3JkcywgaW1hZ2luZVxyXG4gKiBwdXR0aW5nIHRoZSBiYXNlIG9mIHRoZSB2ZWN0b3IgYXQgY29vcmRpbmF0ZXMgKDAsMCkgYW5kIGZpbmRpbmcgdGhlIGFuZ2xlXHJcbiAqIGZyb20gdmVjdG9yICgxLDApIHRvIChwMSxwMikuXHJcbiAqIEBwYXJhbSAge09iamVjdH0gcDEgc3RhcnQgcG9pbnQgb2YgdGhlIHZlY3RvclxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHAyIGVuZCBwb2ludCBvZiB0aGUgdmVjdG9yXHJcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGFuZ2xlXHJcbiAqL1xyXG5USFJFRXguTWF0aC5hbmdsZTIgPSBmdW5jdGlvbihwMSwgcDIpIHtcclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMihwMS54LCBwMS55KTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMihwMi54LCBwMi55KTtcclxuXHR2Mi5zdWIodjEpOyAvLyBzZXRzIHYyIHRvIGJlIG91ciBjaG9yZFxyXG5cdHYyLm5vcm1hbGl6ZSgpO1xyXG5cdGlmKHYyLnkgPCAwKSByZXR1cm4gLU1hdGguYWNvcyh2Mi54KTtcclxuXHRyZXR1cm4gTWF0aC5hY29zKHYyLngpO1xyXG59O1xyXG5cclxuXHJcblRIUkVFeC5NYXRoLnBvbGFyID0gZnVuY3Rpb24ocG9pbnQsIGRpc3RhbmNlLCBhbmdsZSkge1xyXG5cdHZhciByZXN1bHQgPSB7fTtcclxuXHRyZXN1bHQueCA9IHBvaW50LnggKyBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcclxuXHRyZXN1bHQueSA9IHBvaW50LnkgKyBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgcG9pbnRzIGZvciBhIGN1cnZlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0gc3RhcnRQb2ludCAtIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgY3VydmVcclxuICogQHBhcmFtIGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgY3VydmVcclxuICogQHBhcmFtIGJ1bGdlIC0gYSB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBtdWNoIHRvIGN1cnZlXHJcbiAqIEBwYXJhbSBzZWdtZW50cyAtIG51bWJlciBvZiBzZWdtZW50cyBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9pbnRzXHJcbiAqL1xyXG5USFJFRXguQnVsZ2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlLCBzZWdtZW50cyApIHtcclxuXHJcblx0dmFyIHZlcnRleCwgaSxcclxuXHRcdGNlbnRlciwgcDAsIHAxLCBhbmdsZSxcclxuXHRcdHJhZGl1cywgc3RhcnRBbmdsZSxcclxuXHRcdHRoZXRhQW5nbGU7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5zdGFydFBvaW50ID0gcDAgPSBzdGFydFBvaW50ID8gbmV3IFRIUkVFLlZlY3RvcjIoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMCwwKTtcclxuXHR0aGlzLmVuZFBvaW50ID0gcDEgPSBlbmRQb2ludCA/IG5ldyBUSFJFRS5WZWN0b3IyKGVuZFBvaW50LngsIGVuZFBvaW50LnkpIDogbmV3IFRIUkVFLlZlY3RvcjIoMSwwKTtcclxuXHR0aGlzLmJ1bGdlID0gYnVsZ2UgPSBidWxnZSB8fCAxO1xyXG5cclxuXHRhbmdsZSA9IDQgKiBNYXRoLmF0YW4oYnVsZ2UpO1xyXG5cdHJhZGl1cyA9IHAwLmRpc3RhbmNlVG8ocDEpIC8gMiAvIE1hdGguc2luKGFuZ2xlLzIpO1xyXG5cdGNlbnRlciA9IFRIUkVFeC5NYXRoLnBvbGFyKHN0YXJ0UG9pbnQsIHJhZGl1cywgVEhSRUV4Lk1hdGguYW5nbGUyKHAwLHAxKSArIChNYXRoLlBJIC8gMiAtIGFuZ2xlLzIpKTtcclxuXHJcblx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzID0gc2VnbWVudHMgfHwgTWF0aC5tYXgoIE1hdGguYWJzKE1hdGguY2VpbChhbmdsZS8oTWF0aC5QSS8xOCkpKSwgNik7IC8vIEJ5IGRlZmF1bHQgd2FudCBhIHNlZ21lbnQgcm91Z2hseSBldmVyeSAxMCBkZWdyZWVzXHJcblx0c3RhcnRBbmdsZSA9IFRIUkVFeC5NYXRoLmFuZ2xlMihjZW50ZXIsIHAwKTtcclxuXHR0aGV0YUFuZ2xlID0gYW5nbGUgLyBzZWdtZW50cztcclxuXHJcblxyXG5cdHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhwMC54LCBwMC55LCAwKSk7XHJcblxyXG5cdGZvcihpID0gMTsgaSA8PSBzZWdtZW50cyAtIDE7IGkrKykge1xyXG5cclxuXHRcdHZlcnRleCA9IFRIUkVFeC5NYXRoLnBvbGFyKGNlbnRlciwgTWF0aC5hYnMocmFkaXVzKSwgc3RhcnRBbmdsZSArIHRoZXRhQW5nbGUgKiBpKTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjModmVydGV4LngsIHZlcnRleC55LCAwKSk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRXguQnVsZ2VHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuICAgIFxyXG4vKipcclxuICogVmlld2VyIGNsYXNzIGZvciBhIGR4ZiBvYmplY3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIGR4ZiBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudCB0byB3aGljaCB3ZSBhdHRhY2ggdGhlIHJlbmRlcmluZyBjYW52YXNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gd2lkdGggb2YgdGhlIHJlbmRlcmluZyBjYW52YXMgaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIHJlbmRlcmluZyBjYW52YXMgaW4gcGl4ZWxzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb250IC0gYSBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIgXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdlcihkYXRhLCBwYXJlbnQsIHdpZHRoLCBoZWlnaHQsIGZvbnQpIHtcclxuXHJcbiAgICBjcmVhdGVMaW5lVHlwZVNoYWRlcnMoZGF0YSk7XHJcblxyXG4gICAgdmFyIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHNjZW5lIGZyb20gZHhmIG9iamVjdCAoZGF0YSlcclxuICAgIHZhciBpLCBlbnRpdHksIG9iaiwgbWluX3gsIG1pbl95LCBtaW5feiwgbWF4X3gsIG1heF95LCBtYXhfejtcclxuICAgIHZhciBkaW1zID0ge1xyXG4gICAgICAgIG1pbjogeyB4OiBmYWxzZSwgeTogZmFsc2UsIHo6IGZhbHNlfSxcclxuICAgICAgICBtYXg6IHsgeDogZmFsc2UsIHk6IGZhbHNlLCB6OiBmYWxzZX1cclxuICAgIH07XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZW50aXR5ID0gZGF0YS5lbnRpdGllc1tpXTtcclxuICAgICAgICBvYmogPSBkcmF3RW50aXR5KGVudGl0eSwgZGF0YSk7XHJcblxyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21PYmplY3Qob2JqKTtcclxuICAgICAgICAgICAgaWYgKGJib3gubWluLnggJiYgKChkaW1zLm1pbi54ID09PSBmYWxzZSkgfHwgKGRpbXMubWluLnggPiBiYm94Lm1pbi54KSkpIGRpbXMubWluLnggPSBiYm94Lm1pbi54O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5taW4ueSAmJiAoKGRpbXMubWluLnkgPT09IGZhbHNlKSB8fCAoZGltcy5taW4ueSA+IGJib3gubWluLnkpKSkgZGltcy5taW4ueSA9IGJib3gubWluLnk7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1pbi56ICYmICgoZGltcy5taW4ueiA9PT0gZmFsc2UpIHx8IChkaW1zLm1pbi56ID4gYmJveC5taW4ueikpKSBkaW1zLm1pbi56ID0gYmJveC5taW4uejtcclxuICAgICAgICAgICAgaWYgKGJib3gubWF4LnggJiYgKChkaW1zLm1heC54ID09PSBmYWxzZSkgfHwgKGRpbXMubWF4LnggPCBiYm94Lm1heC54KSkpIGRpbXMubWF4LnggPSBiYm94Lm1heC54O1xyXG4gICAgICAgICAgICBpZiAoYmJveC5tYXgueSAmJiAoKGRpbXMubWF4LnkgPT09IGZhbHNlKSB8fCAoZGltcy5tYXgueSA8IGJib3gubWF4LnkpKSkgZGltcy5tYXgueSA9IGJib3gubWF4Lnk7XHJcbiAgICAgICAgICAgIGlmIChiYm94Lm1heC56ICYmICgoZGltcy5tYXgueiA9PT0gZmFsc2UpIHx8IChkaW1zLm1heC56IDwgYmJveC5tYXgueikpKSBkaW1zLm1heC56ID0gYmJveC5tYXguejtcclxuICAgICAgICAgICAgc2NlbmUuYWRkKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgd2lkdGggPSB3aWR0aCB8fCBwYXJlbnQuaW5uZXJXaWR0aDtcclxuICAgIGhlaWdodCA9IGhlaWdodCB8fCBwYXJlbnQuaW5uZXJIZWlnaHQ7XHJcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcclxuXHJcbiAgICB2YXIgdXBwZXJSaWdodENvcm5lciA9IHsgeDogZGltcy5tYXgueCwgeTogZGltcy5tYXgueSB9O1xyXG4gICAgdmFyIGxvd2VyTGVmdENvcm5lciA9IHsgeDogZGltcy5taW4ueCwgeTogZGltcy5taW4ueSB9O1xyXG5cclxuICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGN1cnJlbnQgdmlld3BvcnQgZXh0ZW50c1xyXG4gICAgdmFyIHZwX3dpZHRoID0gdXBwZXJSaWdodENvcm5lci54IC0gbG93ZXJMZWZ0Q29ybmVyLng7XHJcbiAgICB2YXIgdnBfaGVpZ2h0ID0gdXBwZXJSaWdodENvcm5lci55IC0gbG93ZXJMZWZ0Q29ybmVyLnk7XHJcbiAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHtcclxuICAgICAgICB4OiB2cF93aWR0aCAvIDIgKyBsb3dlckxlZnRDb3JuZXIueCxcclxuICAgICAgICB5OiB2cF9oZWlnaHQgLyAyICsgbG93ZXJMZWZ0Q29ybmVyLnlcclxuICAgIH07XHJcblxyXG4gICAgLy8gRml0IGFsbCBvYmplY3RzIGludG8gY3VycmVudCBUaHJlZURYRiB2aWV3ZXJcclxuICAgIHZhciBleHRlbnRzQXNwZWN0UmF0aW8gPSBNYXRoLmFicyh2cF93aWR0aCAvIHZwX2hlaWdodCk7XHJcbiAgICBpZiAoYXNwZWN0UmF0aW8gPiBleHRlbnRzQXNwZWN0UmF0aW8pIHtcclxuICAgICAgICB2cF93aWR0aCA9IHZwX2hlaWdodCAqIGFzcGVjdFJhdGlvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2cF9oZWlnaHQgPSB2cF93aWR0aCAvIGFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgdmlld1BvcnQgPSB7XHJcbiAgICAgICAgYm90dG9tOiAtdnBfaGVpZ2h0IC8gMixcclxuICAgICAgICBsZWZ0OiAtdnBfd2lkdGggLyAyLFxyXG4gICAgICAgIHRvcDogdnBfaGVpZ2h0IC8gMixcclxuICAgICAgICByaWdodDogdnBfd2lkdGggLyAyLFxyXG4gICAgICAgIGNlbnRlcjoge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogY2VudGVyLnlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKHZpZXdQb3J0LmxlZnQsIHZpZXdQb3J0LnJpZ2h0LCB2aWV3UG9ydC50b3AsIHZpZXdQb3J0LmJvdHRvbSwgMSwgMTkpO1xyXG4gICAgY2FtZXJhLnBvc2l0aW9uLnogPSAxMDtcclxuICAgIGNhbWVyYS5wb3NpdGlvbi54ID0gdmlld1BvcnQuY2VudGVyLng7XHJcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IHZpZXdQb3J0LmNlbnRlci55O1xyXG5cclxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcclxuXHJcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcbiAgICBwYXJlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblxyXG4gICAgLy9UT0RPOiBOZWVkIHRvIG1ha2UgdGhpcyBhbiBvcHRpb24gc29tZWhvdyBzbyBvdGhlcnMgY2FuIHJvbGwgdGhlaXIgb3duIGNvbnRyb2xzLlxyXG4gICAgdmFyIGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCBwYXJlbnQpO1xyXG4gICAgY29udHJvbHMudGFyZ2V0LnggPSBjYW1lcmEucG9zaXRpb24ueDtcclxuICAgIGNvbnRyb2xzLnRhcmdldC55ID0gY2FtZXJhLnBvc2l0aW9uLnk7XHJcbiAgICBjb250cm9scy50YXJnZXQueiA9IDA7XHJcbiAgICBjb250cm9scy56b29tU3BlZWQgPSAzO1xyXG5cclxuICAgIC8vVW5jb21tZW50IHRoaXMgdG8gZGlzYWJsZSByb3RhdGlvbiAoZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIHdpdGggMkQgZHJhd2luZ3MpLlxyXG4gICAgLy9jb250cm9scy5lbmFibGVSb3RhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkgeyByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSkgfTtcclxuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMucmVuZGVyKTtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICBjb250cm9scy51cGRhdGUoKTtcclxuXHJcbiAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWxXaWR0aCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gcmVuZGVyZXIuZG9tRWxlbWVudC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBoc2NhbGUgPSB3aWR0aCAvIG9yaWdpbmFsV2lkdGg7XHJcbiAgICAgICAgdmFyIHZzY2FsZSA9IGhlaWdodCAvIG9yaWdpbmFsSGVpZ2h0O1xyXG5cclxuXHJcbiAgICAgICAgY2FtZXJhLnRvcCA9ICh2c2NhbGUgKiBjYW1lcmEudG9wKTtcclxuICAgICAgICBjYW1lcmEuYm90dG9tID0gKHZzY2FsZSAqIGNhbWVyYS5ib3R0b20pO1xyXG4gICAgICAgIGNhbWVyYS5sZWZ0ID0gKGhzY2FsZSAqIGNhbWVyYS5sZWZ0KTtcclxuICAgICAgICBjYW1lcmEucmlnaHQgPSAoaHNjYWxlICogY2FtZXJhLnJpZ2h0KTtcclxuXHJcbi8vICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmZmLCAxKTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RW50aXR5KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBtZXNoO1xyXG4gICAgICAgIGlmKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0FSQycpIHtcclxuICAgICAgICAgICAgbWVzaCA9IGRyYXdBcmMoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdMV1BPTFlMSU5FJyB8fCBlbnRpdHkudHlwZSA9PT0gJ0xJTkUnIHx8IGVudGl0eS50eXBlID09PSAnUE9MWUxJTkUnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3TGluZShlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1RFWFQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3VGV4dChlbnRpdHksIGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZihlbnRpdHkudHlwZSA9PT0gJ1NPTElEJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnUE9JTlQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3UG9pbnQoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdJTlNFUlQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3QmxvY2soZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdTUExJTkUnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3U3BsaW5lKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGVudGl0eS50eXBlID09PSAnTVRFWFQnKSB7XHJcbiAgICAgICAgICAgIG1lc2ggPSBkcmF3TXRleHQoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdFTExJUFNFJykge1xyXG4gICAgICAgICAgICBtZXNoID0gZHJhd0VsbGlwc2UoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYoZW50aXR5LnR5cGUgPT09ICdESU1FTlNJT04nKSB7XHJcbiAgICAgICAgICAgIHZhciBkaW1UeXBlRW51bSA9IGVudGl0eS5kaW1lbnNpb25UeXBlICYgNztcclxuICAgICAgICAgICAgaWYoZGltVHlwZUVudW0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG1lc2ggPSBkcmF3RGltZW5zaW9uKGVudGl0eSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc3VwcG9ydGVkIERpbWVuc2lvbiB0eXBlOiBcIiArIGRpbVR5cGVFbnVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbnN1cHBvcnRlZCBFbnRpdHkgVHlwZTogXCIgKyBlbnRpdHkudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdFbGxpcHNlKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKGVudGl0eSwgZGF0YSk7XHJcblxyXG4gICAgICAgIHZhciB4cmFkID0gTWF0aC5zcXJ0KE1hdGgucG93KGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC54LDIpICsgTWF0aC5wb3coZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LnksMikpO1xyXG4gICAgICAgIHZhciB5cmFkID0geHJhZCplbnRpdHkuYXhpc1JhdGlvO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIoZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LnksIGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC54KTtcclxuXHJcbiAgICAgICAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZShcclxuICAgICAgICAgICAgZW50aXR5LmNlbnRlci54LCAgZW50aXR5LmNlbnRlci55LFxyXG4gICAgICAgICAgICB4cmFkLCB5cmFkLFxyXG4gICAgICAgICAgICBlbnRpdHkuc3RhcnRBbmdsZSwgZW50aXR5LmVuZEFuZ2xlLFxyXG4gICAgICAgICAgICBmYWxzZSwgLy8gQWx3YXlzIGNvdW50ZXJjbG9ja3dpc2VcclxuICAgICAgICAgICAgcm90YXRpb25cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCA1MCApO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyAgbGluZXdpZHRoOiAxLCBjb2xvciA6IGNvbG9yIH0gKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvYmplY3QgdG8gYWRkIHRvIHRoZSBzY2VuZVxyXG4gICAgICAgIHZhciBlbGxpcHNlID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG4gICAgICAgIHJldHVybiBlbGxpcHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdNdGV4dChlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xyXG5cclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KCBlbnRpdHkudGV4dCwge1xyXG4gICAgICAgICAgICBmb250OiBmb250LFxyXG4gICAgICAgICAgICBzaXplOiBlbnRpdHkuaGVpZ2h0ICogKDQvNSksXHJcbiAgICAgICAgICAgIGhlaWdodDogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge2NvbG9yOiBjb2xvcn0gKTtcclxuICAgICAgICB2YXIgdGV4dCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgLy8gTWVhc3VyZSB3aGF0IHdlIHJlbmRlcmVkLlxyXG4gICAgICAgIHZhciBtZWFzdXJlID0gbmV3IFRIUkVFLkJveDMoKTtcclxuICAgICAgICBtZWFzdXJlLnNldEZyb21PYmplY3QoIHRleHQgKTtcclxuXHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCAgPSBtZWFzdXJlLm1heC54IC0gbWVhc3VyZS5taW4ueDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZW5kcyB1cCBiZWluZyB3aWRlciB0aGFuIHRoZSBib3gsIGl0J3Mgc3VwcG9zZWRcclxuICAgICAgICAvLyB0byBiZSBtdWx0aWxpbmUuIERvaW5nIHRoYXQgaW4gdGhyZWVKUyBpcyBvdmVya2lsbC5cclxuICAgICAgICBpZiAodGV4dFdpZHRoID4gZW50aXR5LndpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FuJ3QgcmVuZGVyIHRoaXMgbXVsdGlwbGluZSBNVEVYVCBlbnRpdHksIHNvcnJ5LlwiLCBlbnRpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gMDtcclxuICAgICAgICBzd2l0Y2ggKGVudGl0eS5hdHRhY2htZW50UG9pbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgLy8gVG9wIExlZnRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgLy8gVG9wIENlbnRlclxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LmhlaWdodDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIC8vIFRvcCBSaWdodFxyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi54ID0gZW50aXR5LnBvc2l0aW9uLnggLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnkgPSBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgLy8gTWlkZGxlIExlZnRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAvLyBNaWRkbGUgQ2VudGVyXHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAvLyBNaWRkbGUgUmlnaHRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gQ2VudGVyXHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkucG9zaXRpb24ueCAtIHRleHRXaWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gUmlnaHRcclxuICAgICAgICAgICAgICAgIHRleHQucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54IC0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NwbGluZShlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihlbnRpdHksIGRhdGEpO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gZW50aXR5LmNvbnRyb2xQb2ludHMubWFwKGZ1bmN0aW9uKHZlYykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIodmVjLngsIHZlYy55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGludGVycG9sYXRlZFBvaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBjdXJ2ZTtcclxuICAgICAgICBpZiAoZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDIgfHwgZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDMpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSArIDIgPCBwb2ludHMubGVuZ3RoOyBpID0gaSArIDIpIHtcclxuICAgICAgICBpZiAoZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRQb2ludHMucHVzaC5hcHBseShpbnRlcnBvbGF0ZWRQb2ludHMsIGN1cnZlLmdldFBvaW50cyg1MCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUocG9pbnRzKTtcclxuICAgICAgICAgICAgaW50ZXJwb2xhdGVkUG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCAxMDAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIGludGVycG9sYXRlZFBvaW50cyApO1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBsaW5ld2lkdGg6IDEsIGNvbG9yIDogY29sb3IgfSApO1xyXG4gICAgICAgIHZhciBzcGxpbmVPYmplY3QgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIHJldHVybiBzcGxpbmVPYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0xpbmUoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcbiAgICAgICAgICAgIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSxcclxuICAgICAgICAgICAgbWF0ZXJpYWwsIGxpbmVUeXBlLCB2ZXJ0ZXgsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBidWxnZUdlb21ldHJ5LFxyXG4gICAgICAgICAgICBidWxnZSwgaSwgbGluZTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGdlb21ldHJ5XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgZW50aXR5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZihlbnRpdHkudmVydGljZXNbaV0uYnVsZ2UpIHtcclxuICAgICAgICAgICAgICAgIGJ1bGdlID0gZW50aXR5LnZlcnRpY2VzW2ldLmJ1bGdlO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGVuZFBvaW50ID0gaSArIDEgPCBlbnRpdHkudmVydGljZXMubGVuZ3RoID8gZW50aXR5LnZlcnRpY2VzW2kgKyAxXSA6IGdlb21ldHJ5LnZlcnRpY2VzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1bGdlR2VvbWV0cnkgPSBuZXcgVEhSRUV4LkJ1bGdlR2VvbWV0cnkoc3RhcnRQb2ludCwgZW5kUG9pbnQsIGJ1bGdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoLmFwcGx5KGdlb21ldHJ5LnZlcnRpY2VzLCBidWxnZUdlb21ldHJ5LnZlcnRpY2VzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleCA9IGVudGl0eS52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjModmVydGV4LngsIHZlcnRleC55LCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVudGl0eS5zaGFwZSkgZ2VvbWV0cnkudmVydGljZXMucHVzaChnZW9tZXRyeS52ZXJ0aWNlc1swXSk7XHJcblxyXG5cclxuICAgICAgICAvLyBzZXQgbWF0ZXJpYWxcclxuICAgICAgICBpZihlbnRpdHkubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgbGluZVR5cGUgPSBkYXRhLnRhYmxlcy5saW5lVHlwZS5saW5lVHlwZXNbZW50aXR5LmxpbmVUeXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxpbmVUeXBlICYmIGxpbmVUeXBlLnBhdHRlcm4gJiYgbGluZVR5cGUucGF0dGVybi5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKHsgY29sb3I6IGNvbG9yLCBnYXBTaXplOiA0LCBkYXNoU2l6ZTogNH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgbGluZXdpZHRoOiAxLCBjb2xvcjogY29sb3IgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZihsaW5lVHlwZSAmJiBsaW5lVHlwZS5wYXR0ZXJuICYmIGxpbmVUeXBlLnBhdHRlcm4ubGVuZ3RoICE9PSAwKSB7XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cclxuICAgICAgICAvLyAgICAgICAgICAgLy8gVWdseSBoYWNrIHRvIGFkZCBkaWZmdXNlIHRvIHRoaXMuIE1heWJlIGNvcHkgdGhlIHVuaWZvcm1zIG9iamVjdCBzbyB3ZVxyXG4gICAgICAgIC8vICAgICAgICAgICAvLyBkb24ndCBhZGQgZGlmZnVzZSB0byBhIG1hdGVyaWFsLlxyXG4gICAgICAgIC8vICAgICAgICAgICBsaW5lVHlwZS5tYXRlcmlhbC51bmlmb3Jtcy5kaWZmdXNlID0geyB0eXBlOiAnYycsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoY29sb3IpIH07XHJcblxyXG4gICAgICAgIC8vIFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xyXG4gICAgICAgIC8vIFx0XHR1bmlmb3JtczogbGluZVR5cGUubWF0ZXJpYWwudW5pZm9ybXMsXHJcbiAgICAgICAgLy8gXHRcdHZlcnRleFNoYWRlcjogbGluZVR5cGUubWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG4gICAgICAgIC8vIFx0XHRmcmFnbWVudFNoYWRlcjogbGluZVR5cGUubWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcclxuICAgICAgICAvLyBcdH0pO1xyXG4gICAgICAgIC8vIH1lbHNlIHtcclxuICAgICAgICAvLyBcdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgbGluZXdpZHRoOiAxLCBjb2xvcjogY29sb3IgfSk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZHJhd0FyYyhlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgc3RhcnRBbmdsZSwgZW5kQW5nbGU7XHJcbiAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSAnQ0lSQ0xFJykge1xyXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZW50aXR5LnN0YXJ0QW5nbGUgfHwgMDtcclxuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGVudGl0eS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVudGl0eS5lbmRBbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5BcmNDdXJ2ZShcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgZW50aXR5LnJhZGl1cyxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgZW5kQW5nbGUpO1xyXG5cclxuICAgICAgICB2YXIgcG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCAzMiApO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB9KTtcclxuXHJcbiAgICAgICAgdmFyIGFyYyA9IG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnggPSBlbnRpdHkuY2VudGVyLng7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnkgPSBlbnRpdHkuY2VudGVyLnk7XHJcbiAgICAgICAgYXJjLnBvc2l0aW9uLnogPSBlbnRpdHkuY2VudGVyLno7XHJcblxyXG4gICAgICAgIHJldHVybiBhcmM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1NvbGlkKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBtYXRlcmlhbCwgbWVzaCwgdmVydHMsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG4gICAgICAgIHZlcnRzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzBdLngsIGVudGl0eS5wb2ludHNbMF0ueSwgZW50aXR5LnBvaW50c1swXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzFdLngsIGVudGl0eS5wb2ludHNbMV0ueSwgZW50aXR5LnBvaW50c1sxXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzJdLngsIGVudGl0eS5wb2ludHNbMl0ueSwgZW50aXR5LnBvaW50c1syXS56KSk7XHJcbiAgICAgICAgdmVydHMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlbnRpdHkucG9pbnRzWzNdLngsIGVudGl0eS5wb2ludHNbM10ueSwgZW50aXR5LnBvaW50c1szXS56KSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBkaXJlY3Rpb24gdGhlIHBvaW50cyBhcmUgZmFjaW5nIChjbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2UpXHJcbiAgICAgICAgdmFyIHZlY3RvcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2ZWN0b3IxLnN1YlZlY3RvcnModmVydHNbMV0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IyLnN1YlZlY3RvcnModmVydHNbMl0sIHZlcnRzWzBdKTtcclxuICAgICAgICB2ZWN0b3IxLmNyb3NzKHZlY3RvcjIpO1xyXG5cclxuICAgICAgICAvLyBJZiB6IDwgMCB0aGVuIHdlIG11c3QgZHJhdyB0aGVzZSBpbiByZXZlcnNlIG9yZGVyXHJcbiAgICAgICAgaWYodmVjdG9yMS56IDwgMCkge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygyLCAxLCAwKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDIsIDMsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMygwLCAxLCAyKSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKDEsIDMsIDIpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3VGV4dChlbnRpdHksIGRhdGEpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnksIG1hdGVyaWFsLCB0ZXh0O1xyXG5cclxuICAgICAgICBpZighZm9udClcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignVGV4dCBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgYSBUaHJlZS5qcyBmb250IGxvYWRlZCB3aXRoIFRIUkVFLkZvbnRMb2FkZXIhIExvYWQgYSBmb250IG9mIHlvdXIgY2hvaWNlIGFuZCBwYXNzIHRoaXMgaW50byB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2FtcGxlIGZvciB0aGlzIHJlcG9zaXRvcnkgb3IgVGhyZWUuanMgZXhhbXBsZXMgYXQgaHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzLz9xPXRleHQjd2ViZ2xfZ2VvbWV0cnlfdGV4dCBmb3IgbW9yZSBkZXRhaWxzLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeShlbnRpdHkudGV4dCwgeyBmb250OiBmb250LCBoZWlnaHQ6IDAsIHNpemU6IGVudGl0eS50ZXh0SGVpZ2h0IHx8IDEyIH0pO1xyXG5cclxuICAgICAgICBpZiAoZW50aXR5LnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB6Um90YXRpb24gPSBlbnRpdHkucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5yb3RhdGVaKHpSb3RhdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBnZXRDb2xvcihlbnRpdHksIGRhdGEpIH0pO1xyXG5cclxuICAgICAgICB0ZXh0ID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgICAgICB0ZXh0LnBvc2l0aW9uLnggPSBlbnRpdHkuc3RhcnRQb2ludC54O1xyXG4gICAgICAgIHRleHQucG9zaXRpb24ueSA9IGVudGl0eS5zdGFydFBvaW50Lnk7XHJcbiAgICAgICAgdGV4dC5wb3NpdGlvbi56ID0gZW50aXR5LnN0YXJ0UG9pbnQuejtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BvaW50KGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSwgbWF0ZXJpYWwsIHBvaW50O1xyXG5cclxuICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGVudGl0eS5wb3NpdGlvbi54LCBlbnRpdHkucG9zaXRpb24ueSwgZW50aXR5LnBvc2l0aW9uLnopKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY291bGQgYmUgbW9yZSBlZmZpY2llbnQuIFBvaW50Q2xvdWQgcGVyIGxheWVyP1xyXG5cclxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gMTtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKTtcclxuICAgICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtUG9pbnRzKjMgKTtcclxuICAgICAgICBjb2xvcnNbMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIGNvbG9yc1sxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgY29sb3JzWzJdID0gY29sb3IuYjtcclxuXHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzID0gY29sb3JzO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBzaXplOiAwLjA1LCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XHJcbiAgICAgICAgcG9pbnQgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgc2NlbmUuYWRkKHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RGltZW5zaW9uKGVudGl0eSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBibG9jayA9IGRhdGEuYmxvY2tzW2VudGl0eS5ibG9ja107XHJcblxyXG4gICAgICAgIGlmICghYmxvY2sgfHwgIWJsb2NrLmVudGl0aWVzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcbiAgICAgICAgLy8gaWYoZW50aXR5LmFuY2hvclBvaW50KSB7XHJcbiAgICAgICAgLy8gICAgIGdyb3VwLnBvc2l0aW9uLnggPSBlbnRpdHkuYW5jaG9yUG9pbnQueDtcclxuICAgICAgICAvLyAgICAgZ3JvdXAucG9zaXRpb24ueSA9IGVudGl0eS5hbmNob3JQb2ludC55O1xyXG4gICAgICAgIC8vICAgICBncm91cC5wb3NpdGlvbi56ID0gZW50aXR5LmFuY2hvclBvaW50Lno7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2suZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkRW50aXR5ID0gZHJhd0VudGl0eShibG9jay5lbnRpdGllc1tpXSwgZGF0YSwgZ3JvdXApO1xyXG4gICAgICAgICAgICBpZihjaGlsZEVudGl0eSkgZ3JvdXAuYWRkKGNoaWxkRW50aXR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmxvY2soZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gZGF0YS5ibG9ja3NbZW50aXR5Lm5hbWVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghYmxvY2suZW50aXRpZXMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGVudGl0eS54U2NhbGUpIGdyb3VwLnNjYWxlLnggPSBlbnRpdHkueFNjYWxlO1xyXG4gICAgICAgIGlmKGVudGl0eS55U2NhbGUpIGdyb3VwLnNjYWxlLnkgPSBlbnRpdHkueVNjYWxlO1xyXG5cclxuICAgICAgICBpZihlbnRpdHkucm90YXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucm90YXRpb24ueiA9IGVudGl0eS5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbnRpdHkucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgZ3JvdXAucG9zaXRpb24ueCA9IGVudGl0eS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBncm91cC5wb3NpdGlvbi55ID0gZW50aXR5LnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgIGdyb3VwLnBvc2l0aW9uLnogPSBlbnRpdHkucG9zaXRpb24uejtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2NrLmVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZEVudGl0eSA9IGRyYXdFbnRpdHkoYmxvY2suZW50aXRpZXNbaV0sIGRhdGEsIGdyb3VwKTtcclxuICAgICAgICAgICAgaWYoY2hpbGRFbnRpdHkpIGdyb3VwLmFkZChjaGlsZEVudGl0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3IoZW50aXR5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gMHgwMDAwMDA7IC8vZGVmYXVsdFxyXG4gICAgICAgIGlmKGVudGl0eS5jb2xvcikgY29sb3IgPSBlbnRpdHkuY29sb3I7XHJcbiAgICAgICAgZWxzZSBpZihkYXRhLnRhYmxlcyAmJiBkYXRhLnRhYmxlcy5sYXllciAmJiBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXSlcclxuICAgICAgICAgICAgY29sb3IgPSBkYXRhLnRhYmxlcy5sYXllci5sYXllcnNbZW50aXR5LmxheWVyXS5jb2xvcjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYoY29sb3IgPT0gbnVsbCB8fCBjb2xvciA9PT0gMHhmZmZmZmYpIHtcclxuICAgICAgICAgICAgY29sb3IgPSAweDAwMDAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVUeXBlU2hhZGVycyhkYXRhKSB7XHJcbiAgICAgICAgdmFyIGx0eXBlLCB0eXBlO1xyXG4gICAgICAgIGlmKCFkYXRhLnRhYmxlcyB8fCAhZGF0YS50YWJsZXMubGluZVR5cGUpIHJldHVybjtcclxuICAgICAgICB2YXIgbHR5cGVzID0gZGF0YS50YWJsZXMubGluZVR5cGUubGluZVR5cGVzO1xyXG5cclxuICAgICAgICBmb3IodHlwZSBpbiBsdHlwZXMpIHtcclxuICAgICAgICAgICAgbHR5cGUgPSBsdHlwZXNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmKCFsdHlwZS5wYXR0ZXJuKSBjb250aW51ZTtcclxuICAgICAgICAgICAgbHR5cGUubWF0ZXJpYWwgPSBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKGx0eXBlLnBhdHRlcm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXNoZWRMaW5lU2hhZGVyKHBhdHRlcm4pIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgZGFzaGVkTGluZVNoYWRlciA9IHt9LFxyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDAuMDtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLmFicyhwYXR0ZXJuW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyAnY29tbW9uJyBdLFxyXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgJ2ZvZycgXSxcclxuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzogeyB0eXBlOiAnZnYxJywgdmFsdWU6IHBhdHRlcm4gfSxcclxuICAgICAgICAgICAgICAgICdwYXR0ZXJuTGVuZ3RoJzogeyB0eXBlOiAnZicsIHZhbHVlOiB0b3RhbExlbmd0aCB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIudmVydGV4U2hhZGVyID0gW1xyXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTsnLFxyXG5cclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdLFxyXG5cclxuICAgICAgICAgICAgJ3ZMaW5lRGlzdGFuY2UgPSBsaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7JyxcclxuXHJcbiAgICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyk7XHJcblxyXG4gICAgICAgIGRhc2hlZExpbmVTaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBbXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZTsnLFxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBwYXR0ZXJuWycgKyBwYXR0ZXJuLmxlbmd0aCArICddOycsXHJcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHBhdHRlcm5MZW5ndGg7JyxcclxuXHJcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCcgXSxcclxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCcgXSxcclxuXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuXHJcbiAgICAgICAgICAgICdmbG9hdCBwb3MgPSBtb2QodkxpbmVEaXN0YW5jZSwgcGF0dGVybkxlbmd0aCk7JyxcclxuXHJcbiAgICAgICAgICAgICdmb3IgKCBpbnQgaSA9IDA7IGkgPCAnICsgcGF0dGVybi5sZW5ndGggKyAnOyBpKysgKSB7JyxcclxuICAgICAgICAgICAgJ3BvcyA9IHBvcyAtIGFicyhwYXR0ZXJuW2ldKTsnLFxyXG4gICAgICAgICAgICAnaWYoIHBvcyA8IDAuMCApIHsnLFxyXG4gICAgICAgICAgICAnaWYoIHBhdHRlcm5baV0gPiAwLjAgKSB7JyxcclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgb3BhY2l0eSApOycsXHJcbiAgICAgICAgICAgICdicmVhazsnLFxyXG4gICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICdkaXNjYXJkOycsXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgICd9JyxcclxuXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0sXHJcbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyAnZm9nX2ZyYWdtZW50JyBdLFxyXG5cclxuICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhc2hlZExpbmVTaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEV4dGVudHMoc2NlbmUpIHsgXHJcbiAgICAgICAgZm9yKHZhciBjaGlsZCBvZiBzY2VuZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcclxuICAgICAgICAgICAgaWYoY2hpbGQucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi54LCBtaW5YKTtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihjaGlsZC5wb3NpdGlvbi55LCBtaW5ZKTtcclxuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi54LCBtYXhYKTtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChjaGlsZC5wb3NpdGlvbi55LCBtYXhZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgbWluOiB7IHg6IG1pblgsIHk6IG1pblkgfSwgbWF4OiB7IHg6IG1heFgsIHk6IG1heFkgfX07XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8gU2hvdy9IaWRlIGhlbHBlcnMgZnJvbSBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvZWZmZWN0cy9oaWRlLW9yLXNob3ctYW4tZWxlbWVudC00Mi9cclxuLy8gZ2V0IHRoZSBkZWZhdWx0IGRpc3BsYXkgc3R5bGUgb2YgYW4gZWxlbWVudFxyXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSh0YWcpIHtcclxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgMCk7XHJcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xyXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMCk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuXHJcbiAgICB2YXIgZG9jID0gKGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQpLmRvY3VtZW50O1xyXG5cclxuICAgIC8vIElFIHN1cHBvcnRcclxuICAgIGRvYy53cml0ZSgpO1xyXG4gICAgZG9jLmNsb3NlKCk7XHJcblxyXG4gICAgdmFyIHRlc3RFbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRlc3RFbCk7XHJcbiAgICB2YXIgZGlzcGxheSA9ICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUodGVzdEVsLCBudWxsKSA6IHRlc3RFbC5jdXJyZW50U3R5bGUpLmRpc3BsYXlcclxuICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxufVxyXG5cclxuLy8gYWN0dWFsIHNob3cvaGlkZSBmdW5jdGlvbiB1c2VkIGJ5IHNob3coKSBhbmQgaGlkZSgpIGJlbG93XHJcbmZ1bmN0aW9uIHNob3dIaWRlKGVsLCBzaG93KSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2xkZGlzcGxheScpLFxyXG4gICAgZGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXksXHJcbiAgICBjb21wdXRlZERpc3BsYXkgPSAod2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKSA6IGVsLmN1cnJlbnRTdHlsZSkuZGlzcGxheTtcclxuXHJcbiAgICBpZiAoc2hvdykge1xyXG4gICAgICAgIGlmICghdmFsdWUgJiYgZGlzcGxheSA9PT0gJ25vbmUnKSBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIChjb21wdXRlZERpc3BsYXkgPT09ICdub25lJykpIHZhbHVlID0gdmFsdWUgfHwgZGVmYXVsdERpc3BsYXkoZWwubm9kZU5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZGlzcGxheSAmJiBkaXNwbGF5ICE9PSAnbm9uZScgfHwgIShjb21wdXRlZERpc3BsYXkgPT0gJ25vbmUnKSlcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW9sZGRpc3BsYXknLCAoY29tcHV0ZWREaXNwbGF5ID09ICdub25lJykgPyBkaXNwbGF5IDogY29tcHV0ZWREaXNwbGF5KTtcclxuICAgIH1cclxuICAgIGlmICghc2hvdyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuc3R5bGUuZGlzcGxheSA9PT0gJycpXHJcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZSB8fCAnJyA6ICdub25lJztcclxufVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBzaG93KGVsKSB7IHNob3dIaWRlKGVsLCB0cnVlKTsgfVxyXG5mdW5jdGlvbiBoaWRlKGVsKSB7IHNob3dIaWRlKGVsKTsgfVxyXG5cclxuXHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n') }]) });